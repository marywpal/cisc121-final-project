# cisc121-final-project
Chosen algorithm: Binary Searching
For my program, I am making a small interactive game that consists of the user choosing a number between 1-100 in their heads, and then making the program figure out what number it is by the user either telling it that the number it chose is higher or lower than the number it had given them. For this program, I chose binary searching as it makes the most sense of the two searching algorithms to use, considering it is a program that involves eliminating series of numbers before or after the given midpoints. 




Decomposition: 
In terms of planning out my breakdown for how this program is to be built, I will first need to set a limit of the numbers that can be chosen from 1 to 100. I then want my program to choose a random number 1-100 each time it is used, so that the process can end up taking different amounts of steps each time depending on the starting number and the user’s chosen number. My next step is to prompt the user to either tell the program whether their chosen number was higher, lower, or equal to their chosen number. From then, the searching algorithm will start up, using that first randomly chosen number as one of the endpoints to be used to find the midpoint. This will continue, on, asking the user after every midpoint whether their number is higher, lower, or equal to it, until the list is refined to the point of getting their number. After the number is found, the program will have kept track of the number of guesses it needed to find the user’s number, then telling the user. The game will end once the number has been found, prompting the user to play again if they would like to.

Pattern Recognition: 
In terms of pattern recognition for the binary searching algorithm being used in this game, the list of numbers gets cut in half from the midpoint for every single time that the user tells the program that their number is higher or lower than the current given number. The game keeps this going until the number that is guessed is correct. These are patterns that are seen when using a binary searching algorithm.


Abstraction: 
This program, despite being built to guess a number of which the user is thinking of, does not actually care what exactly the number the user is thinking of is. The only think that the program really cares about in terms of the number itself, is whether the user claims that the number they have chosen is higher or lower than what the program had guessed. The abstraction allows the program to only have to focus on the portions which have to be inserted into variables -- like high, low, guess, guess_count, and first_guess -- as well as the general rules of the game. An example of the rules portion is how the program gives a certain response if there is no possible way, given the responses from the user, that their number was consistent throughout the entire game. When this happens, the program is prompted to tell them that they should do so, making it so that the game does not continue on or break.


Algorithm Design:
The algorithm for this number guessing game starts by confirming and setting the lower and upper limits (low = 1, high = 100) and setting the guess count to one. For the first guess, the program will select a random number within the range and prompts the user. After receiving the user's response—“Higher,” “Lower,” or “Correct”—the program updates the bounds accordingly: if the user indicates the number is higher, the lower bound is increased to one above the current guess; if lower, the upper bound is decreased to one below the current guess. If the user responds “Correct,” the game ends and the total number of guesses is displayed. For all subsequent guesses, the computer uses binary search by calculating the midpoint of the current range as the next guess, incrementing the guess count each time. The program also checks for inconsistencies, such as when the lower bound exceeds the upper bound, indicating that the user’s responses do not align with a single number. This process repeats—updating bounds, computing midpoints, and prompting the user—until the correct number is identified.
